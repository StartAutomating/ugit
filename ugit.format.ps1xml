<?xml version="1.0" encoding="utf-16"?>
<!-- Generated with EZOut 2.0.6: Install-Module EZOut or https://github.com/StartAutomating/EZOut -->
<Configuration>
  <Controls>
    <Control>
      <Name>Git.Diff.ChangeSet</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <NewLine />
              <ExpressionBinding>
                <ScriptBlock>$moduleName = 'ugit'

            do {
                $lm = Get-Module -Name $moduleName -ErrorAction Ignore
                if (-not $lm) { continue } 
                if ($lm.FormatPartsLoaded) { break }
                $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
                    foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
                        $ParentNode = $partNodeName.Node.ParentNode
                        "$($ParentNode.Name)={
            $($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
                    }
                }) -join [Environment]::NewLine
                New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
                    Import-Module -Global
                $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
                
                if (-not $lm.OnRemove) {
                    $lm.OnRemove = $onRemove
                } else {
                    $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
                }
                $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force
            
            } while ($false)
            
        
@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Verbose' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        "@@ -$($_.LineStart),$($_.LineCount) +$($_.NewLineStart),$($_.NewLineCount) @@"
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Verbose' ) -join ''</ScriptBlock>
              </ExpressionBinding>
              <NewLine />
              <ExpressionBinding>
                <ScriptBlock>
        $changeLines = @($_.Changes -split '(?&gt;\r\n|\n)' -ne '')
        @(foreach ($changeLine in $changeLines) {
            [Environment]::NewLine
            if ($changeLine.StartsWith('+')) {
                &amp; ${ugit_Format-RichText} -InputObject ($changeLine -replace "[\s\r\n]+$") -ForegroundColor Success
            }
            elseif ($changeLine.StartsWith('-')) {
                &amp; ${ugit_Format-RichText} -InputObject ($changeLine -replace "[\s\r\n]+$") -ForegroundColor Error                
            }
            else {                
                $changeLine
            }
            
        }) -join ''
    </ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>GitRemoteBranchList</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>
    (' ' * 4) + @($_ | 
        Format-Table -Property BranchName, Status |
        Out-String -Width ($host.UI.RawUI.BufferSize.Width - 4)
    ) -split [Environment]::NewLine -join (
        [Environment]::NewLine + (' ' * 4)
    )
</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>${ugit_Format-RichText}</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>
    &lt;#
    .Synopsis
        Formats the text color of output
    .Description
        Formats the text color of output

        * ForegroundColor
        * BackgroundColor
        * Bold
        * Underline
    .Notes
        Stylized Output works in two contexts at present:
        * Rich consoles (Windows Terminal, PowerShell.exe, Pwsh.exe) (when $host.UI.SupportsVirtualTerminal)
        * Web pages (Based off the presence of a $Request variable, or when $host.UI.SupportsHTML (you must add this property to $host.UI))
    #&gt;
    [Management.Automation.Cmdlet("Format","Object")]
    [ValidateScript({
        $canUseANSI     = $host.UI.SupportsVirtualTerminal
        $canUseHTML     = $Request -or $host.UI.SupportsHTML -or $OutputMode -eq 'HTML'
        if (-not ($canUseANSI -or $canUseHTML)) { return $false}
        return $true
    })]
    [OutputType([string])]
    param(
    # The input object
    [Parameter(ValueFromPipeline)]
    [PSObject]
    $InputObject,
    
    # The foreground color
    [string]$ForegroundColor,

    # The background color
    [string]$BackgroundColor,

    # If set, will render as bold
    [switch]$Bold,

    # If set, will render as italic.
    [Alias('Italics')]
    [switch]$Italic,

    # If set, will render as faint
    [switch]$Faint,

    # If set, will render as hidden text.
    [switch]$Hide,

    # If set, will render as blinking (not supported in all terminals or HTML)
    [switch]$Blink,    

    # If set, will render as strikethru
    [Alias('Strikethrough', 'Crossout')]
    [switch]$Strikethru,

    # If set, will underline text
    [switch]$Underline,

    # If set, will double underline text.
    [switch]$DoubleUnderline,    

    # If set, will invert text
    [switch]$Invert,

    # If provided, will create a hyperlink to a given uri
    [Alias('Hyperlink', 'Href')]
    [uri]
    $Link,

    # If set, will not clear formatting
    [switch]$NoClear,

    # The alignment.  Defaulting to Left.
    # Setting an alignment will pad the remaining space on each line.
    [ValidateSet('Left','Right','Center')]
    [string]
    $Alignment,

    # The length of a line.  By default, the buffer width
    [int]$LineLength = $($host.UI.RawUI.BufferSize.Width)
    )    

    begin {
        $canUseANSI     = $host.UI.SupportsVirtualTerminal
        $canUseHTML     = $Request -or $host.UI.SupportsHTML -or $OutputMode -eq 'HTML'
        $knownStreams = @{
            Output='';Error='BrightRed';Warning='BrightYellow';
            Verbose='BrightCyan';Debug='Yellow';Progress='Cyan';
            Success='BrightGreen';Failure='Red';Default=''}

        $ansiCode = [Regex]::new(@'
        (?&lt;ANSI_Code&gt;
        (?-i)\e                                                                                   # An Escape
        \[                                                                                        # Followed by a bracket
        (?&lt;ParameterBytes&gt;[\d\:\;\&lt;\=\&gt;\?]{0,})                                                   # Followed by zero or more parameter  
        bytes
        (?&lt;IntermediateBytes&gt;[\s\!\"\#\$\%\&amp;\'\(\)\*\+\,\-\.\/]{0,})                              # Followed by zero or more 
        intermediate bytes
        (?&lt;FinalByte&gt;[\@ABCDEFGHIJKLMNOPQRSTUVWXYZ\[\\\]\^_\`abcdefghijklmnopqrstuvwxyz\{\|\}\~]) # Followed by a final byte
        
        )                
'@)
        $esc = [char]0x1b
        $standardColors = 'Black', 'Red', 'Green', 'Yellow', 'Blue','Magenta', 'Cyan', 'White'
        $brightColors   = 'BrightBlack', 'BrightRed', 'BrightGreen', 'BrightYellow', 'BrightBlue','BrightMagenta', 'BrightCyan', 'BrightWhite'

        $allOutput      = @()

        $n =0
        $cssClasses = @()        
        $colorAttributes =         
            @(:nextColor foreach ($hc in $ForegroundColor,$BackgroundColor) {
                $n++
                if (-not $hc) { continue }
                if ($hc[0] -eq $esc) {
                    if ($canUseANSI) { 
                        $hc; continue
                    }
                }
        
                $ansiStartPoint = if ($n -eq 1) { 30 } else { 40 } 
                if ($knownStreams.ContainsKey($hc)) {
                    $i = $brightColors.IndexOf($knownStreams[$hc])
                    if ($canUseHTML) {
                        $cssClasses += $hc
                    } else {
                        if ($i -ge 0 -and $canUseANSI) {
                            '' + $esc + "[1;$($ansiStartPoint + $i)m"
                        } else {
                            $i = $standardColors.IndexOf($knownStreams[$hc])
                            if ($i -ge 0 -and $canUseANSI) {
                                '' + $esc + "[1;$($ansiStartPoint + $i)m"
                            } elseif ($i -le 0 -and $canUseANSI) {                        
                                '' + $esc + "[$($ansistartpoint + 8):5m"
                            }
                        }
                    }
                    continue nextColor
                }
                elseif ($standardColors -contains $hc) {
                    for ($i = 0; $i -lt $standardColors.Count;$i++) {
                        if ($standardColors[$i] -eq $hc) {
                            if ($canUseANSI -and -not $canUseHTML) {
                                '' + $esc + "[$($ansiStartPoint + $i)m"
                            } else {
                                $cssClasses += $standardColors[$i]
                            }
                            continue nextColor
                        }
                    }
                } elseif ($brightColors -contains $hc) {
                    for ($i = 0; $i -lt $brightColors.Count;$i++) {
                        if ($brightColors[$i] -eq $hc) {
                            if ($canUseANSI -and -not $canUseHTML) {
                                '' + $esc + "[1;$($ansiStartPoint + $i)m"
                            } else {
                                $cssClasses += $standardColors[$i]
                            }
                            continue nextColor
                        }
                    }
                }                
                elseif ($psStyle -and $psStyle.Formatting.$hc -and 
                    $psStyle.Formatting.$hc -match '^\e') {
                    if ($canUseANSI -and -not $canUseHTML) {
                        $psStyle.Formatting.$hc
                    } else {
                        $cssClasses += "formatting-$hc"
                    }
                }
                elseif (-not $n -and $psStyle -and $psStyle.Foreground.$hc -and 
                    $psStyle.Foreground.$hc -match '^\e' ) {
                    if ($canUseANSI -and -not $canUseHTML) {
                        $psStyle.Foreground.$hc
                    } else {
                        $cssClasses += "foreground-$hc"
                    }                   
                }
                elseif ($n -and $psStyle -and $psStyle.Background.$hc -and
                    $psStyle.Background.$hc -match '^\e') {
                    if ($canUseANSI -and -not $canUseHTML) {
                        $psStyle.Background.$hc
                    } else {
                        $cssClasses += "background-$hc"
                    }                    
                }

        
        
                if ($hc -and $hc -notmatch '^[\#\e]') {
                    $placesToLook=
                        @(if ($hc.Contains('.')) {
                            $module, $setting = $hc -split '\.', 2
                            $theModule = Get-Module $module
                            $theModule.PrivateData.Color,
                                $theModule.PrivateData.Colors,
                                $theModule.PrivateData.Colour,
                                $theModule.PrivateData.Colours,
                                $theModule.PrivateData.EZOut,
                                $global:PSColors,
                                $global:PSColours
                        } else {
                            $setting = $hc
                            $moduleColorSetting = $theModule.PrivateData.PSColors.$setting
                        })
        
                    foreach ($place in $placesToLook) {
                        if (-not $place) { continue }
                        foreach ($propName in $setting -split '\.') {
                            $place = $place.$propName
                            if (-not $place) { break }
                        }
                        if ($place -and "$place".StartsWith('#') -and 4,7 -contains "$place".Length) {
                            $hc = $place
                            continue
                        }
                    }
                    if (-not $hc.StartsWith -or -not $hc.StartsWith('#')) {
                        continue
                    }
                }
                $r,$g,$b = if ($hc.Length -eq 7) {
                    [int]::Parse($hc[1..2]-join'', 'HexNumber')
                    [int]::Parse($hc[3..4]-join '', 'HexNumber')
                    [int]::Parse($hc[5..6] -join'', 'HexNumber')
                }elseif ($hc.Length -eq 4) {
                    [int]::Parse($hc[1], 'HexNumber') * 16
                    [int]::Parse($hc[2], 'HexNumber') * 16
                    [int]::Parse($hc[3], 'HexNumber') * 16
                }
        
                if ($canUseHTML) {
                    if ($n -eq 1) { "color:$hc" }
                    elseif ($n -eq 2) { "background-color:$hc"} 
                }
                elseif ($canUseANSI) {
                    if ($n -eq 1) { $esc+"[38;2;$r;$g;${b}m" }
                    elseif ($n -eq 2) { $esc+"[48;2;$r;$g;${b}m" }
                }
                
            })
        
        $styleAttributes = @() + $colorAttributes
        
        $styleAttributes += @(
            if ($Bold) {
                if ($canUseHTML) {"font-weight:bold"}
                elseif ($canUseANSI) { '' + $esc + "[1m" }
            }
            if ($Faint) {
                if ($canUseHTML) { "opacity:.5" }
                elseif ($canUseANSI) { '' + $esc + "[2m" }
            }
            if ($Italic) {                
                if ($canUseHTML) { "font-weight:bold" }
                elseif ($canUseANSI)  {'' + $esc + "[3m" }
            }
            
            if ($Underline -and -not $doubleUnderline) {             
                if ($canUseHTML) { "text-decoration:underline"} 
                elseif ($canUseANSI) {'' +$esc + "[4m" }
            }

            if ($Blink) {             
                if ($canUseANSI) { '' +$esc + "[5m" }
            }

            if ($invert) {
                if ($canUseHTML) {"filter:invert(100%)"}
                elseif ($canUseANSI) { '' + $esc + "[7m"}
            }

            if ($hide) {
                if ($canUseHTML) {"opacity:0"}
                elseif ($canUseANSI) { '' + $esc + "[8m"}
            }
            
            if ($Strikethru) {             
                if ($canUseHTML) {"text-decoration: line-through"}
                elseif ($canUseANSI) { '' +$esc + "[9m" }
            }
            
            if ($DoubleUnderline) {
                if ($canUseHTML) { "border-bottom: 3px double;"}
                elseif ($canUseANSI) {'' +$esc + "[21m" }
            }

            if ($Alignment -and $canUseHTML) {
                "display:block;text-align:$($Alignment.ToLower())"
            }

            if ($Link) {
                if ($canUseHTML) { 
                    # Hyperlinks need to be a nested element
                    # so we will not add it to style attributes for HTML
                }
                elseif ($canUseANSI) {
                    # For ANSI,
                    '' + $esc + ']8;;' + $Link + $esc + '\'   
                }
            }
            
        )
        
        $header =
            if ($canUseHTML) {        
                "&lt;span$(
                    if ($styleAttributes) { " style='$($styleAttributes -join ';')'"}
                )$(
                    if ($cssClasses) { " class='$($cssClasses -join ' ')'"}
                )&gt;" + $(
                    if ($Link) {
                        "&lt;a href='$link'&gt;"
                    }
                )
            } elseif ($canUseANSI) {
                $styleAttributes -join ''
            }
    }

    process {
        $inputObjectAsString =
            "$(if ($inputObject) { $inputObject | Out-String})".Trim()

        $inputObjectAsString = 
            if ($Alignment -and -not $canUseHTML) {
                (@(foreach ($inputObjectLine in ($inputObjectAsString -split '(?&gt;\r\n|\n)')) {
                    $inputObjectLength = $ansiCode.Replace($inputObjectLine, '').Length
                    if ($inputObjectLength -lt $LineLength) {
                        if ($Alignment -eq 'Left') {
                            $inputObjectLine
                        } elseif ($Alignment -eq 'Right') {
                            (' ' * ($LineLength - $inputObjectLength)) + $inputObjectLine                            
                        } else {
                            $half = ($LineLength - $inputObjectLength)/2
                            (' ' * [Math]::Floor($half)) + $inputObjectLine +
                            (' ' * [Math]::Ceiling($half))
                        }
                    }
                    else {
                        $inputObjectLine
                    }
                }) -join [Environment]::NewLine) + [Environment]::newline
            } else {
                $inputObjectAsString
            }

        $allOutput +=
            if ($header) {
                "$header" + $inputObjectAsString
            }
            elseif ($inputObject) {
                $inputObjectAsString
            }
    }

    end {
        
        if (-not $NoClear) {
            $allOutput += 
                if ($canUseHTML) {
                    if ($Link) {
                        "&lt;/a&gt;"
                    }
                    "&lt;/span&gt;"
                }
                elseif ($canUseANSI) {
                    if ($Bold -or $Faint -or $colorAttributes -match '\[1;') {
                        "$esc[22m"
                    }
                    if ($Italic) {
                        "$esc[23m"
                    }
                    if ($Underline -or $doubleUnderline) {
                        "$esc[24m"
                    }
                    if ($Blink) {
                        "$esc[25m"
                    }                
                    if ($Invert) {
                        "$esc[27m"
                    }
                    if ($hide) {
                        "$esc[28m"
                    }
                    if ($Strikethru) {
                        "$esc[29m"
                    }
                    if ($ForegroundColor) {
                        "$esc[39m"
                    }
                    if ($BackgroundColor) {
                        "$esc[49m"
                    }

                    if ($Link) {
                        "$esc]8;;$esc\"
                    }
                
                    if (-not ($Underline -or $Bold -or $Invert -or $ForegroundColor -or $BackgroundColor)) {
                        '' + $esc + '[0m'
                    }
                }
        }

        $allOutput -join ''
    }
</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>${ugit_SetOutputStyle}</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>&lt;#
.Synopsis
    Adds style to a format output
.Description
    Adds style information to a format output, including:

    * ForegroundColor
    * BackgroundColor
    * Bold
    * Underline
.Notes
    Stylized Output works in two contexts at present:
    * Rich consoles (Windows Terminal, PowerShell.exe, Pwsh.exe) (when $host.UI.SupportsVirtualTerminal)
    * Web pages (Based off the presence of a $Request variable, or when $host.UI.SupportsHTML (you must add this property to $host.UI))

    IsFormatPart: true
#&gt;
param(
[string]$ForegroundColor,
[string]$BackgroundColor,
[switch]$Bold,
[switch]$Underline,
[switch]$Invert
)

$canUseANSI = $host.UI.SupportsVirtualTerminal
$canUseHTML = $Request -or $host.UI.SupportsHTML
if (-not ($canUseANSI -or $canUseHTML)) { return }

$knownStreams = @{
    Output='';Error='BrightRed';Warning='BrightYellow';
    Verbose='BrightCyan';Debug='Yellow';Progress='Cyan';
    Success='BrightGreen';Failure='Red';Default=''}
$standardColors = 'Black', 'Red', 'Green', 'Yellow', 'Blue','Magenta', 'Cyan', 'White'
$brightColors   = 'BrightBlack', 'BrightRed', 'BrightGreen', 'BrightYellow', 'BrightBlue','BrightMagenta', 'BrightCyan', 'BrightWhite'
$n =0
$cssClasses = @()
$styleAttributes =
    @(:nextColor foreach ($hc in $ForegroundColor,$BackgroundColor) {
        $n++
        if (-not $hc) { continue }
        if ($hc[0] -eq [char]0x1b) {
            if ($canUseANSI) { 
                $hc; continue
            }
        }

        $ansiStartPoint = if ($n -eq 1) { 30 } else { 40 } 
        if ($knownStreams.ContainsKey($hc)) {
            $i = $brightColors.IndexOf($knownStreams[$hc])
            if ($canUseHTML) {
                $cssClasses += $hc
            } else {
                if ($i -ge 0 -and $canUseANSI) {
                    '' + [char]0x1b + "[1;$($ansiStartPoint + $i)m"
                } else {
                    $i = $standardColors.IndexOf($knownStreams[$hc])
                    if ($i -ge 0 -and $canUseANSI) {
                        '' + [char]0x1b + "[1;$($ansiStartPoint + $i)m"
                    } elseif ($i -le 0 -and $canUseANSI) {                        
                        '' + [char]0x1b + "[$($ansistartpoint + 8):5m"
                    }
                }
            }
            continue nextColor
        }
        elseif ($standardColors -contains $hc) {
            for ($i = 0; $i -lt $standardColors.Count;$i++) {
                if ($standardColors[$i] -eq $hc) {
                    if ($canUseANSI -and -not $canUseHTML) {
                        '' + [char]0x1b + "[$($ansiStartPoint + $i)m"
                    } else {
                        $cssClasses += $standardColors[$i]
                    }
                    continue nextColor
                }
            }
        } elseif ($brightColors -contains $hc) {
            for ($i = 0; $i -lt $brightColors.Count;$i++) {
                if ($brightColors[$i] -eq $hc) {
                    if ($canUseANSI -and -not $canUseHTML) {
                        '' + [char]0x1b + "[1;$($ansiStartPoint + $i)m"
                    } else {
                        $cssClasses += $standardColors[$i]
                    }
                    continue nextColor
                }
            }
        }


        if ($hc -and -not $hc.StartsWith('#')) { 
            $placesToLook=
                @(if ($hc.Contains('.')) {
                    $module, $setting = $hc -split '\.', 2
                    $theModule = Get-Module $module
                    $theModule.PrivateData.Color,
                        $theModule.PrivateData.Colors,
                        $theModule.PrivateData.Colour,
                        $theModule.PrivateData.Colours,
                        $theModule.PrivateData.EZOut,
                        $global:PSColors,
                        $global:PSColours
                } else {
                    $setting = $hc
                    $moduleColorSetting = $theModule.PrivateData.PSColors.$setting
                })

            foreach ($place in $placesToLook) {
                if (-not $place) { continue }
                foreach ($propName in $setting -split '\.') {
                    $place = $place.$propName
                    if (-not $place) { break }
                }
                if ($place -and "$place".StartsWith('#') -and 4,7 -contains "$place".Length) {
                    $hc = $place
                    continue
                }
            }
            if (-not $hc.StartsWith -or -not $hc.StartsWith('#')) {
                continue
            }
        }
        $r,$g,$b = if ($hc.Length -eq 7) {
            [int]::Parse($hc[1..2]-join'', 'HexNumber')
            [int]::Parse($hc[3..4]-join '', 'HexNumber')
            [int]::Parse($hc[5..6] -join'', 'HexNumber')
        }elseif ($hc.Length -eq 4) {
            [int]::Parse($hc[1], 'HexNumber') * 16
            [int]::Parse($hc[2], 'HexNumber') * 16
            [int]::Parse($hc[3], 'HexNumber') * 16
        }

        if ($canUseHTML) {
            if ($n -eq 1) { "color:$hc" }
            elseif ($n -eq 2) { "background-color:$hc"} 
        }
        elseif ($canUseANSI) {
            if ($n -eq 1) { [char]0x1b+"[38;2;$r;$g;${b}m" }
            elseif ($n -eq 2) { [char]0x1b+"[48;2;$r;$g;${b}m" }
        }
        
    })


if ($Bold) {
    $styleAttributes += 
        if ($canUseHTML) {
            "font-weight:bold"
        }
        elseif ($canUseANSI) 
        {
            [char]0x1b + "[1m"
        }
}

if ($Underline) {
    $styleAttributes += 
        if ($canUseHTML) {
            "text-decoration:underline"
        } elseif ($canUseANSI) {
            [char]0x1b + "[4m"
        }
}

if ($Invert) {
    $styleAttributes += 
        if ($canUseHTML) {
            "filter:invert(100%)"
        } elseif ($canUseANSI) {
            [char]0x1b + "[7m"            
        }
}

if ($canUseHTML) {
   
    "&lt;span$(
        if ($styleAttributes) { " style='$($styleAttributes -join ';')'"}
    )$(
        if ($cssClasses) { " class='$($cssClasses -join ' ')'"}
    )&gt;"
} elseif ($canUseANSI) {
    $styleAttributes -join ''
}</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>${ugit_ClearOutputStyle}</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>&lt;#
.Synopsis
    Clears the output style
.Description
    Clears ANSI output style or closes the most recent span element.

    ANSI stylization can be toggled off individually (for instance, to stop applying an -Underline but leave the color unchanged)
.Notes
    IsFormatPart: true
#&gt;
param(
# If set, will explicitly clear ANSI Bold
[switch]
$Bold,
# If set, will explicitly clear ANSI Underline
[switch]
$Underline,
# If set, will explicitly clear ANSI Invert
[switch]
$Invert,
# If set, will explicitly clear ANSI Foreground Color
[switch]
$ForegroundColor,
# If set, will explicitly clear ANSI Background Color
[switch]
$BackgroundColor
)
@(if ($request -or $host.UI.SupportsHTML) {
    "&lt;/span&gt;"
} elseif ($Host.UI.SupportsVirtualTerminal) {
    if ($Underline) {
        [char]0x1b + "[24m"
    }
    if ($Bold) {        
        [char]0x1b + "[21m"
    }
    if ($Invert) {
        [char]0x1b + '[27m'
    }
    if ($ForegroundColor) {
        [char]0x1b + '[39m'
    }
    if ($BackgroundColor) {
        [char]0x1b + '[49m'
    }

    if (-not ($Underline -or $Bold -or $Invert -or $ForegroundColor -or $BackgroundColor)) {
        [char]0x1b + '[0m'
    }
    
}) -join ''</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
  </Controls>
  <ViewDefinitions>
    <View>
      <Name>git.blame</Name>
      <ViewSelectedBy>
        <TypeName>git.blame</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>GitRoot</PropertyName>
      </GroupBy>
      <TableControl>
        <TableHeaders>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
            <Alignment>Right</Alignment>
          </TableColumnHeader>
          <TableColumnHeader>
            <Alignment>Left</Alignment>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <TableColumnItems>
              <TableColumnItem>
                <PropertyName>CommitHash</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>Author</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>CommitDate</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>Line</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>Content</PropertyName>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
    <View>
      <Name>git.branch</Name>
      <ViewSelectedBy>
        <TypeName>git.branch</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>GitRoot</PropertyName>
      </GroupBy>
      <TableControl>
        <TableHeaders>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <TableColumnItems>
              <TableColumnItem>
                <PropertyName>BranchName</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>IsCurrentBranch</PropertyName>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
    <View>
      <Name>git.branch.detail</Name>
      <ViewSelectedBy>
        <TypeName>git.branch.detail</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>GitRoot</PropertyName>
      </GroupBy>
      <TableControl>
        <TableHeaders>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <Wrap />
            <TableColumnItems>
              <TableColumnItem>
                <PropertyName>BranchName</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>BranchHash</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>IsCurrentBranch</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>CommitMessage</PropertyName>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
    <View>
      <Name>git.checkout.newbranch</Name>
      <ViewSelectedBy>
        <TypeName>git.checkout.newbranch</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>GitRoot</PropertyName>
      </GroupBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <Text>Switched to a new branch </Text>
              <ExpressionBinding>
                <ScriptBlock>$moduleName = 'ugit'

            do {
                $lm = Get-Module -Name $moduleName -ErrorAction Ignore
                if (-not $lm) { continue } 
                if ($lm.FormatPartsLoaded) { break }
                $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
                    foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
                        $ParentNode = $partNodeName.Node.ParentNode
                        "$($ParentNode.Name)={
            $($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
                    }
                }) -join [Environment]::NewLine
                New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
                    Import-Module -Global
                $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
                
                if (-not $lm.OnRemove) {
                    $lm.OnRemove = $onRemove
                } else {
                    $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
                }
                $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force
            
            } while ($false)
            
        
@(&amp; ${ugit_Format-RichText} -ForegroundColor 'verbose' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>"'$($_.BranchName)'"</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'verbose' ) -join ''</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>git.checkout.alreadyonbranch</Name>
      <ViewSelectedBy>
        <TypeName>git.checkout.alreadyonbranch</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>GitRoot</PropertyName>
      </GroupBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <Text>Already on </Text>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.BranchName -in 'main', 'master'</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>$moduleName = 'ugit'

            do {
                $lm = Get-Module -Name $moduleName -ErrorAction Ignore
                if (-not $lm) { continue } 
                if ($lm.FormatPartsLoaded) { break }
                $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
                    foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
                        $ParentNode = $partNodeName.Node.ParentNode
                        "$($ParentNode.Name)={
            $($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
                    }
                }) -join [Environment]::NewLine
                New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
                    Import-Module -Global
                $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
                
                if (-not $lm.OnRemove) {
                    $lm.OnRemove = $onRemove
                } else {
                    $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
                }
                $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force
            
            } while ($false)
            
        
@(&amp; ${ugit_Format-RichText} -ForegroundColor 'warning' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.BranchName -in 'main', 'master'</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>"'$($_.BranchName)'"</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.BranchName -in 'main', 'master'</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'warning' ) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.BranchName -notin 'main', 'master'</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'verbose' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.BranchName -notin 'main', 'master'</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>"'$($_.BranchName)'"</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.BranchName -notin 'main', 'master'</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'verbose' ) -join ''</ScriptBlock>
              </ExpressionBinding>
              <NewLine />
              <ExpressionBinding>
                <PropertyName>Status</PropertyName>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>git.checkout.switchbranch</Name>
      <ViewSelectedBy>
        <TypeName>git.checkout.switchbranch</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>GitRoot</PropertyName>
      </GroupBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <Text>Switched to </Text>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.BranchName -in 'main', 'master'</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>$moduleName = 'ugit'

            do {
                $lm = Get-Module -Name $moduleName -ErrorAction Ignore
                if (-not $lm) { continue } 
                if ($lm.FormatPartsLoaded) { break }
                $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
                    foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
                        $ParentNode = $partNodeName.Node.ParentNode
                        "$($ParentNode.Name)={
            $($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
                    }
                }) -join [Environment]::NewLine
                New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
                    Import-Module -Global
                $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
                
                if (-not $lm.OnRemove) {
                    $lm.OnRemove = $onRemove
                } else {
                    $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
                }
                $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force
            
            } while ($false)
            
        
@(&amp; ${ugit_Format-RichText} -ForegroundColor 'warning' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.BranchName -in 'main', 'master'</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>"'$($_.BranchName)'"</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.BranchName -in 'main', 'master'</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'warning' ) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.BranchName -notin 'main', 'master'</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'verbose' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.BranchName -notin 'main', 'master'</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>"'$($_.BranchName)'"</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.BranchName -notin 'main', 'master'</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'verbose' ) -join ''</ScriptBlock>
              </ExpressionBinding>
              <NewLine />
              <ExpressionBinding>
                <PropertyName>Status</PropertyName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.Modified </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        @(
            "  Untracked modifications:"
            ""
            $($_.Modified | Out-String).Trim()
        ) -join [Environment]::NewLine
    </ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>git.clone</Name>
      <ViewSelectedBy>
        <TypeName>git.clone</TypeName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <Text>Cloned </Text>
              <ExpressionBinding>
                <ScriptBlock>$moduleName = 'ugit'

            do {
                $lm = Get-Module -Name $moduleName -ErrorAction Ignore
                if (-not $lm) { continue } 
                if ($lm.FormatPartsLoaded) { break }
                $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
                    foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
                        $ParentNode = $partNodeName.Node.ParentNode
                        "$($ParentNode.Name)={
            $($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
                    }
                }) -join [Environment]::NewLine
                New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
                    Import-Module -Global
                $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
                
                if (-not $lm.OnRemove) {
                    $lm.OnRemove = $onRemove
                } else {
                    $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
                }
                $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force
            
            } while ($false)
            
        
@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Success' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <PropertyName>GitUrl</PropertyName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Success' ) -join ''</ScriptBlock>
              </ExpressionBinding>
              <Text> into </Text>
              <ExpressionBinding>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'verbose' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <PropertyName>Directory</PropertyName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'verbose' ) -join ''</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Git.Commit.Info</Name>
      <ViewSelectedBy>
        <TypeName>Git.Commit.Info</TypeName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>$moduleName = 'ugit'

            do {
                $lm = Get-Module -Name $moduleName -ErrorAction Ignore
                if (-not $lm) { continue } 
                if ($lm.FormatPartsLoaded) { break }
                $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
                    foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
                        $ParentNode = $partNodeName.Node.ParentNode
                        "$($ParentNode.Name)={
            $($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
                    }
                }) -join [Environment]::NewLine
                New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
                    Import-Module -Global
                $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
                
                if (-not $lm.OnRemove) {
                    $lm.OnRemove = $onRemove
                } else {
                    $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
                }
                $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force
            
            } while ($false)
            
        
@(&amp; ${ugit_Format-RichText} -ForegroundColor 'verbose' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        "[$($_.BranchName) $($_.CommitHash)] "
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'verbose' ) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <PropertyName>CommitMessage</PropertyName>
              </ExpressionBinding>
              <NewLine />
              <ExpressionBinding>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'verbose' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        " $($_.FilesChanged) files changed"
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'verbose' ) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        $_.Insertions
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Success' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        $_.Insertions
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        ", $($_.Insertions) insertions(+)"
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        $_.Insertions
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Success' ) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        $_.Deletions
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Error' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        $_.Deletions
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        ", $($_.Deletions) deletions(-)"
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        $_.Deletions
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Error' ) -join ''</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Git.Diff.ChangeSet</Name>
      <ViewSelectedBy>
        <TypeName>Git.Diff.ChangeSet</TypeName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock> $_ </ScriptBlock>
                <CustomControlName>Git.Diff.ChangeSet</CustomControlName>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Git.Diff</Name>
      <ViewSelectedBy>
        <TypeName>Git.Diff</TypeName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>$moduleName = 'ugit'

            do {
                $lm = Get-Module -Name $moduleName -ErrorAction Ignore
                if (-not $lm) { continue } 
                if ($lm.FormatPartsLoaded) { break }
                $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
                    foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
                        $ParentNode = $partNodeName.Node.ParentNode
                        "$($ParentNode.Name)={
            $($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
                    }
                }) -join [Environment]::NewLine
                New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
                    Import-Module -Global
                $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
                
                if (-not $lm.OnRemove) {
                    $lm.OnRemove = $onRemove
                } else {
                    $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
                }
                $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force
            
            } while ($false)
            
        
@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Verbose' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        @(        
        '@ '
        if ($_.From -eq $_.To) {
            $_.From
        } else {
            $_.From + '--&gt;' + $_.To
        }

        ' @'
        " ($($_.FromHash)..$($_.ToHash)) "
        ) -join ''
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Verbose' ) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.Binary </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Warning' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.Binary </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        "Binary files differ"
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.Binary </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Warning' ) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> $_.ChangeSet </ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>Git.Diff.ChangeSet</CustomControlName>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Git.Grep.Match</Name>
      <ViewSelectedBy>
        <TypeName>Git.Grep.Match</TypeName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>$moduleName = 'ugit'

            do {
                $lm = Get-Module -Name $moduleName -ErrorAction Ignore
                if (-not $lm) { continue } 
                if ($lm.FormatPartsLoaded) { break }
                $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
                    foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
                        $ParentNode = $partNodeName.Node.ParentNode
                        "$($ParentNode.Name)={
            $($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
                    }
                }) -join [Environment]::NewLine
                New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
                    Import-Module -Global
                $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
                
                if (-not $lm.OnRemove) {
                    $lm.OnRemove = $onRemove
                } else {
                    $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
                }
                $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force
            
            } while ($false)
            
        
@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Magenta' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <PropertyName>GitPath</PropertyName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Magenta' ) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Cyan' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <Text>:</Text>
              <ExpressionBinding>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Cyan' ) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        # LineNumber in green (if present)
        $_.LineNumber
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Green' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        # LineNumber in green (if present)
        $_.LineNumber
    </ScriptBlock>
                </ItemSelectionCondition>
                <PropertyName>LineNumber</PropertyName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        # LineNumber in green (if present)
        $_.LineNumber
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Green' ) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        # Colons in cyan
        $_.LineNumber
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Cyan' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <Text>:</Text>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        # Colons in cyan
        $_.LineNumber
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Cyan' ) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        # ColumnNumber in green (if present)
        $_.ColumnNumber
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Green' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        # ColumnNumber in green (if present)
        $_.ColumnNumber
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        '' + $_.LineNumber
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        # ColumnNumber in green (if present)
        $_.ColumnNumber
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Green' ) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        # Colons in cyan
        $_.ColumnNumber
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Cyan' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <Text>:</Text>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        # Colons in cyan
        $_.ColumnNumber
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Cyan' ) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        # Higlight the match with a replacer.
        [Regex]::Replace($_.Line, $_.Pattern, {
            param($match)
            &amp; ${ugit_Format-RichText} -ForegroundColor Error -InputObject "$match"
        }, $(if ($_.CaseSensitive) { 'None'} else { 'IgnoreCase' }))        
    </ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>git.init</Name>
      <ViewSelectedBy>
        <TypeName>git.init</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>GitRoot</PropertyName>
      </GroupBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>$moduleName = 'ugit'

            do {
                $lm = Get-Module -Name $moduleName -ErrorAction Ignore
                if (-not $lm) { continue } 
                if ($lm.FormatPartsLoaded) { break }
                $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
                    foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
                        $ParentNode = $partNodeName.Node.ParentNode
                        "$($ParentNode.Name)={
            $($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
                    }
                }) -join [Environment]::NewLine
                New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
                    Import-Module -Global
                $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
                
                if (-not $lm.OnRemove) {
                    $lm.OnRemove = $onRemove
                } else {
                    $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
                }
                $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force
            
            } while ($false)
            
        
@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Verbose' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        "Initialized empty git repository in "
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Verbose' ) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Success' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <PropertyName>GitRoot</PropertyName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Success' ) -join ''</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Git.Log</Name>
      <ViewSelectedBy>
        <TypeName>Git.Log</TypeName>
      </ViewSelectedBy>
      <TableControl>
        <TableHeaders>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
            <Alignment>Right</Alignment>
          </TableColumnHeader>
          <TableColumnHeader>
            <Alignment>Left</Alignment>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <Wrap />
            <TableColumnItems>
              <TableColumnItem>
                <PropertyName>GitUserName</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>CommitDate</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>CommitMessage</PropertyName>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
    <View>
      <Name>IncludeCommitHash</Name>
      <ViewSelectedBy>
        <TypeName>Git.Log</TypeName>
      </ViewSelectedBy>
      <TableControl>
        <TableHeaders>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
            <Alignment>Right</Alignment>
          </TableColumnHeader>
          <TableColumnHeader>
            <Alignment>Left</Alignment>
          </TableColumnHeader>
          <TableColumnHeader>
            <Alignment>Left</Alignment>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <Wrap />
            <TableColumnItems>
              <TableColumnItem>
                <PropertyName>GitUserName</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>CommitDate</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>CommitHash</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>CommitMessage</PropertyName>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
    <View>
      <Name>Git.Merge.Log</Name>
      <ViewSelectedBy>
        <TypeName>Git.Merge.Log</TypeName>
      </ViewSelectedBy>
      <TableControl>
        <TableHeaders>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
            <Alignment>Right</Alignment>
          </TableColumnHeader>
          <TableColumnHeader>
            <Alignment>Left</Alignment>
          </TableColumnHeader>
          <TableColumnHeader>
            <Alignment>Left</Alignment>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <Wrap />
            <TableColumnItems>
              <TableColumnItem>
                <PropertyName>GitUserName</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>CommitDate</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>MergeHash</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>CommitMessage</PropertyName>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
    <View>
      <Name>git.output</Name>
      <ViewSelectedBy>
        <TypeName>git.output</TypeName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <PropertyName>GitOutput</PropertyName>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Git.Pull.FastForward</Name>
      <ViewSelectedBy>
        <TypeName>Git.Pull.FastForward</TypeName>
        <TypeName>Git.Pull.Strategy</TypeName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> -not $_.Strategy</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        "&gt;&gt; Fast Forward &gt;&gt;"        
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.strategy </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>$moduleName = 'ugit'

            do {
                $lm = Get-Module -Name $moduleName -ErrorAction Ignore
                if (-not $lm) { continue } 
                if ($lm.FormatPartsLoaded) { break }
                $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
                    foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
                        $ParentNode = $partNodeName.Node.ParentNode
                        "$($ParentNode.Name)={
            $($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
                    }
                }) -join [Environment]::NewLine
                New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
                    Import-Module -Global
                $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
                
                if (-not $lm.OnRemove) {
                    $lm.OnRemove = $onRemove
                } else {
                    $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
                }
                $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force
            
            } while ($false)
            
        
@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Warning' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.strategy </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        "&gt;&gt; Merge made by '$($_.Strategy)' strategy &gt;&gt;"
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.strategy </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Warning' ) -join ''</ScriptBlock>
              </ExpressionBinding>
              <NewLine />
              <ExpressionBinding>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'verbose' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        "$($_.GitUrl)"        
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'verbose' ) -join ''</ScriptBlock>
              </ExpressionBinding>
              <NewLine />
              <ExpressionBinding>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'verbose' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        "$($_.LastCommitHash)..$($_.CommitHash)  $($_.DestinationBranch) -&gt; $($_.SourceBranch)"
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'verbose' ) -join ''</ScriptBlock>
              </ExpressionBinding>
              <NewLine />
              <ExpressionBinding>
                <ScriptBlock>
        $maxLength = 0 
        foreach ($change in $_.Changes) {
            if ($change.FilePath.Length -gt $maxLength) {
                $maxLength = $change.FilePath.Length
            }
        }
        @(foreach ($change in $_.Changes) {
            '  ' + $($change.FilePath.PadRight($maxLength, ' ')) + " | $($changes.LinesChanged)" + ' ' + (
                @(
                    if ($change.LinesInserted) {
                        . ${ugit_SetOutputStyle} -ForegroundColor Success
                        '+' * $change.LinesInserted
                        . ${ugit_ClearOutputStyle}
                    }
                ) -join ''
            ) + (
                @(
                    if ($change.LinesDeleted) {
                        . ${ugit_SetOutputStyle} -ForegroundColor Error
                        '-' * $change.LinesDeleted
                        . ${ugit_ClearOutputStyle}
                    }
                ) -join ''
            )
        }) -join [Environment]::NewLine
    </ScriptBlock>
              </ExpressionBinding>
              <NewLine />
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.Changes </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'verbose' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.Changes </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        " $($_.FilesChanged) files changed"
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.Changes </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'verbose' ) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        $_.Insertions
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Success' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        $_.Insertions
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        ", $($_.Insertions) insertions(+)"
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        $_.Insertions
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Success' ) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        $_.Deletions
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Error' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        $_.Deletions
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        ", $($_.Deletions) deletions(-)"
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        $_.Deletions
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Error' ) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        $_.NewFiles
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        @([System.Environment]::NewLine
        "++ New Files ++" 
        [System.Environment]::NewLine) -join ''
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        $_.NewFiles
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        $_.NewFiles | Out-String 
    </ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Git.Pull.No.Update</Name>
      <ViewSelectedBy>
        <TypeName>Git.Pull.No.Update</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>GitRoot</PropertyName>
      </GroupBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>$moduleName = 'ugit'

            do {
                $lm = Get-Module -Name $moduleName -ErrorAction Ignore
                if (-not $lm) { continue } 
                if ($lm.FormatPartsLoaded) { break }
                $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
                    foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
                        $ParentNode = $partNodeName.Node.ParentNode
                        "$($ParentNode.Name)={
            $($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
                    }
                }) -join [Environment]::NewLine
                New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
                    Import-Module -Global
                $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
                
                if (-not $lm.OnRemove) {
                    $lm.OnRemove = $onRemove
                } else {
                    $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
                }
                $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force
            
            } while ($false)
            
        
@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Success' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <Text>Everything up to date.</Text>
              <ExpressionBinding>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Success' ) -join ''</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Git.Push.Info</Name>
      <ViewSelectedBy>
        <TypeName>Git.Push.Info</TypeName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>
        "To " + $_.GitUrl + [Environment]::NewLine
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>$moduleName = 'ugit'

            do {
                $lm = Get-Module -Name $moduleName -ErrorAction Ignore
                if (-not $lm) { continue } 
                if ($lm.FormatPartsLoaded) { break }
                $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
                    foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
                        $ParentNode = $partNodeName.Node.ParentNode
                        "$($ParentNode.Name)={
            $($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
                    }
                }) -join [Environment]::NewLine
                New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
                    Import-Module -Global
                $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
                
                if (-not $lm.OnRemove) {
                    $lm.OnRemove = $onRemove
                } else {
                    $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
                }
                $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force
            
            } while ($false)
            
        
@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Verbose' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        "   " + $_.LastCommitHash + '..' + $_.CommitHash + "  " + $_.SourceBranch + " -&gt; " + $_.DestinationBranch
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Verbose' ) -join ''</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Git.Push.Upstream</Name>
      <ViewSelectedBy>
        <TypeName>Git.Push.Upstream</TypeName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>
        "To " + $_.GitUrl + [Environment]::NewLine
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>$moduleName = 'ugit'

            do {
                $lm = Get-Module -Name $moduleName -ErrorAction Ignore
                if (-not $lm) { continue } 
                if ($lm.FormatPartsLoaded) { break }
                $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
                    foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
                        $ParentNode = $partNodeName.Node.ParentNode
                        "$($ParentNode.Name)={
            $($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
                    }
                }) -join [Environment]::NewLine
                New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
                    Import-Module -Global
                $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
                
                if (-not $lm.OnRemove) {
                    $lm.OnRemove = $onRemove
                } else {
                    $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
                }
                $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force
            
            } while ($false)
            
        
@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Verbose' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        " * [new branch]      " + $_.SourceBranch + " -&gt; " + $_.DestinationBranch + [Environment]::NewLine
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Verbose' ) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        "    Create a pull request for $($_.SourceBranch) on $($_.CreatePullRequestUrl.host) by visiting:" + [Environment]::NewLine
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        "      " + $_.CreatePullRequestUrl
    </ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Git.Reference.Log</Name>
      <ViewSelectedBy>
        <TypeName>Git.Reference.Log</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>GitRoot</PropertyName>
      </GroupBy>
      <TableControl>
        <TableHeaders>
          <TableColumnHeader>
            <Label>Name</Label>
            <Alignment>Right</Alignment>
          </TableColumnHeader>
          <TableColumnHeader>
            <Label>#</Label>
            <Alignment>Left</Alignment>
          </TableColumnHeader>
          <TableColumnHeader>
            <Alignment>Left</Alignment>
          </TableColumnHeader>
          <TableColumnHeader>
            <Label>Command</Label>
            <Alignment>Right</Alignment>
          </TableColumnHeader>
          <TableColumnHeader>
            <Alignment>Left</Alignment>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <TableColumnItems>
              <TableColumnItem>
                <ScriptBlock> $_.Name </ScriptBlock>
              </TableColumnItem>
              <TableColumnItem>
                <ScriptBlock> $_.'Number' + ' '</ScriptBlock>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>Hash</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <ScriptBlock> $_.Command + ':'</ScriptBlock>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>Message</PropertyName>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
    <View>
      <Name>Git.Remote.Name</Name>
      <ViewSelectedBy>
        <TypeName>Git.Remote.Name</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>GitRoot</PropertyName>
      </GroupBy>
      <TableControl>
        <TableHeaders>
          <TableColumnHeader>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <TableColumnItems>
              <TableColumnItem>
                <PropertyName>RemoteName</PropertyName>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
    <View>
      <Name>Git.Remote.Url</Name>
      <ViewSelectedBy>
        <TypeName>Git.Remote.Url</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>GitRoot</PropertyName>
      </GroupBy>
      <TableControl>
        <TableHeaders>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <TableColumnItems>
              <TableColumnItem>
                <PropertyName>RemoteName</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>RemoteUrl</PropertyName>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
    <View>
      <Name>Git.Remote.Show</Name>
      <ViewSelectedBy>
        <TypeName>Git.Remote.Show</TypeName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <Text>* remote </Text>
              <ExpressionBinding>
                <ScriptBlock>$moduleName = 'ugit'

            do {
                $lm = Get-Module -Name $moduleName -ErrorAction Ignore
                if (-not $lm) { continue } 
                if ($lm.FormatPartsLoaded) { break }
                $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
                    foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
                        $ParentNode = $partNodeName.Node.ParentNode
                        "$($ParentNode.Name)={
            $($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
                    }
                }) -join [Environment]::NewLine
                New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
                    Import-Module -Global
                $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
                
                if (-not $lm.OnRemove) {
                    $lm.OnRemove = $onRemove
                } else {
                    $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
                }
                $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force
            
            } while ($false)
            
        
@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Verbose' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <PropertyName>RemoteName</PropertyName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Verbose' ) -join ''</ScriptBlock>
              </ExpressionBinding>
              <NewLine />
              <Text>  HEAD branch: </Text>
              <ExpressionBinding>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Verbose' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <PropertyName>HeadBranch</PropertyName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Verbose' ) -join ''</ScriptBlock>
              </ExpressionBinding>
              <NewLine />
              <Text>  URLS: </Text>
              <NewLine />
              <ExpressionBinding>
                <ScriptBlock>        
        (' ' * 4) + @(
            $_.RemoteUrls | Out-String -Width ($host.UI.RawUI.BufferSize.Width - 4)
        ) -split [Environment]::NewLine -join (
            [Environment]::NewLine + (' ' * 4)
        )
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.RemoteBranches </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        [Environment]::NewLine +  '  Remote Branches:' + [Environment]::NewLine
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.RemoteBranches </ScriptBlock>
                </ItemSelectionCondition>
                <PropertyName>RemoteBranches</PropertyName>
                <CustomControlName>GitRemoteBranchList</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.LocalBranches </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        [Environment]::NewLine +  '  Local Branches:' + [Environment]::NewLine
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.LocalBranches </ScriptBlock>
                </ItemSelectionCondition>
                <PropertyName>LocalBranches</PropertyName>
                <CustomControlName>GitRemoteBranchList</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.TrackedUpstreams </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        [Environment]::NewLine +  '  Tracked Upstreams:' + [Environment]::NewLine
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.TrackedUpstreams </ScriptBlock>
                </ItemSelectionCondition>
                <PropertyName>TrackedUpstreams</PropertyName>
                <CustomControlName>GitRemoteBranchList</CustomControlName>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>git.removal</Name>
      <ViewSelectedBy>
        <TypeName>git.removal</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>GitRoot</PropertyName>
      </GroupBy>
      <TableControl>
        <TableHeaders>
          <TableColumnHeader>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <TableColumnItems>
              <TableColumnItem>
                <PropertyName>RemovedFile</PropertyName>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
    <View>
      <Name>Git.Shortlog</Name>
      <ViewSelectedBy>
        <TypeName>Git.Shortlog</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>GitRoot</PropertyName>
      </GroupBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>$moduleName = 'ugit'

            do {
                $lm = Get-Module -Name $moduleName -ErrorAction Ignore
                if (-not $lm) { continue } 
                if ($lm.FormatPartsLoaded) { break }
                $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
                    foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
                        $ParentNode = $partNodeName.Node.ParentNode
                        "$($ParentNode.Name)={
            $($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
                    }
                }) -join [Environment]::NewLine
                New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
                    Import-Module -Global
                $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
                
                if (-not $lm.OnRemove) {
                    $lm.OnRemove = $onRemove
                } else {
                    $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
                }
                $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force
            
            } while ($false)
            
        
@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Success' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <PropertyName>name</PropertyName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Success' ) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.Email </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Warning' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.Email </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        " &lt; " +  $_.Email +  ' &gt;'
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.Email </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Warning' ) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Verbose' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        ' (' + $_.Count + '):'
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Verbose' ) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        $lineAndIndent = [Environment]::Newline + (' ' * 4)
        $lineAndIndent + $(@(
            $_.Commits
        ) -join $lineAndIndent)
    </ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Git.Shortlog.Summary</Name>
      <ViewSelectedBy>
        <TypeName>Git.Shortlog.Summary</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>GitRoot</PropertyName>
      </GroupBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>
        ' ' * 4
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>$moduleName = 'ugit'

            do {
                $lm = Get-Module -Name $moduleName -ErrorAction Ignore
                if (-not $lm) { continue } 
                if ($lm.FormatPartsLoaded) { break }
                $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
                    foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
                        $ParentNode = $partNodeName.Node.ParentNode
                        "$($ParentNode.Name)={
            $($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
                    }
                }) -join [Environment]::NewLine
                New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
                    Import-Module -Global
                $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
                
                if (-not $lm.OnRemove) {
                    $lm.OnRemove = $onRemove
                } else {
                    $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
                }
                $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force
            
            } while ($false)
            
        
@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Verbose' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        $_.Count.ToString().PadLeft(3, ' ')
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Verbose' ) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        ' ' * 2
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <PropertyName>Name</PropertyName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.Email </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> ' &lt;' + $_.Email + '&gt;' </ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Git.Stash.Apply</Name>
      <ViewSelectedBy>
        <TypeName>Git.Stash.Apply</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>GitRoot</PropertyName>
      </GroupBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <Text>On Branch: </Text>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.BranchName -notin 'main', 'master' </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>$moduleName = 'ugit'

            do {
                $lm = Get-Module -Name $moduleName -ErrorAction Ignore
                if (-not $lm) { continue } 
                if ($lm.FormatPartsLoaded) { break }
                $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
                    foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
                        $ParentNode = $partNodeName.Node.ParentNode
                        "$($ParentNode.Name)={
            $($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
                    }
                }) -join [Environment]::NewLine
                New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
                    Import-Module -Global
                $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
                
                if (-not $lm.OnRemove) {
                    $lm.OnRemove = $onRemove
                } else {
                    $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
                }
                $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force
            
            } while ($false)
            
        
@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Verbose' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.BranchName -notin 'main', 'master' </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> $_.BranchName </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.BranchName -notin 'main', 'master' </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Verbose' ) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.BranchName -in 'main', 'master' </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Warning' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.BranchName -in 'main', 'master' </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> $_.BranchName </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.BranchName -in 'main', 'master' </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Warning' ) -join ''</ScriptBlock>
              </ExpressionBinding>
              <NewLine />
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.Staged </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> 
        "Changes Staged For Commit:
  (use git commit -m to commit)" + [Environment]::NewLine
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.Staged </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        (@(foreach ($line in $($_.Staged | Select-Object ChangeType, Path | Out-String -Width ($host.UI.RawUI.BufferSize.Width - 8)) -split '(?&gt;\r\n|\n)') {
            (" " * 4) + $line
        }) -join [Environment]::NewLine) + [Environment]::NewLine
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.Unstaged </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> 
        "Changes Not Staged For Commit:
  (use git add &lt;file&gt; to add, git restore &lt;file&gt; to discard changes)" + [Environment]::NewLine
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.Unstaged</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        (@(foreach ($line in $($_.Unstaged | Select-Object ChangeType, Path | Out-String -Width ($host.UI.RawUI.BufferSize.Width - 8)) -split '(?&gt;\r\n|\n)') {
            (" " * 4) + $line
        }) -join [Environment]::NewLine) + [Environment]::NewLine
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.Untracked </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        "Untracked Files:
  (use git add &lt;file&gt; to include in commit)" + [Environment]::NewLine
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.Untracked</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        @(foreach ($line in $($_.Untracked | Out-String -Width ($host.UI.RawUI.BufferSize.Width - 8)) -split '(?&gt;\r\n|\n)') {
            (" " * 4) + $line
        }) -join [Environment]::NewLine
    </ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Git.Stash.Drop</Name>
      <ViewSelectedBy>
        <TypeName>Git.Stash.Drop</TypeName>
      </ViewSelectedBy>
      <TableControl>
        <TableHeaders>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <TableColumnItems>
              <TableColumnItem>
                <PropertyName>Number</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>CommitHash</PropertyName>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
    <View>
      <Name>Git.Stash.Entry</Name>
      <ViewSelectedBy>
        <TypeName>Git.Stash.Entry</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>GitRoot</PropertyName>
      </GroupBy>
      <TableControl>
        <AutoSize />
        <TableHeaders>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <TableColumnItems>
              <TableColumnItem>
                <PropertyName>Number</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>Message</PropertyName>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
    <View>
      <Name>git.stash.nothing</Name>
      <ViewSelectedBy>
        <TypeName>git.stash.nothing</TypeName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <NewLine />
              <ExpressionBinding>
                <ScriptBlock>$moduleName = 'ugit'

            do {
                $lm = Get-Module -Name $moduleName -ErrorAction Ignore
                if (-not $lm) { continue } 
                if ($lm.FormatPartsLoaded) { break }
                $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
                    foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
                        $ParentNode = $partNodeName.Node.ParentNode
                        "$($ParentNode.Name)={
            $($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
                    }
                }) -join [Environment]::NewLine
                New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
                    Import-Module -Global
                $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
                
                if (-not $lm.OnRemove) {
                    $lm.OnRemove = $onRemove
                } else {
                    $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
                }
                $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force
            
            } while ($false)
            
        
@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Verbose' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <Text>Nothing to stash</Text>
              <ExpressionBinding>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Verbose' ) -join ''</ScriptBlock>
              </ExpressionBinding>
              <NewLine />
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Git.Status</Name>
      <ViewSelectedBy>
        <TypeName>Git.Status</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>GitRoot</PropertyName>
      </GroupBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <Text>On Branch: </Text>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.BranchName -notin 'main', 'master' </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>$moduleName = 'ugit'

            do {
                $lm = Get-Module -Name $moduleName -ErrorAction Ignore
                if (-not $lm) { continue } 
                if ($lm.FormatPartsLoaded) { break }
                $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
                    foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
                        $ParentNode = $partNodeName.Node.ParentNode
                        "$($ParentNode.Name)={
            $($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
                    }
                }) -join [Environment]::NewLine
                New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
                    Import-Module -Global
                $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
                
                if (-not $lm.OnRemove) {
                    $lm.OnRemove = $onRemove
                } else {
                    $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
                }
                $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force
            
            } while ($false)
            
        
@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Verbose' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.BranchName -notin 'main', 'master' </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> $_.BranchName </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.BranchName -notin 'main', 'master' </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Verbose' ) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.BranchName -in 'main', 'master' </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Warning' -NoClear) -join ''</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.BranchName -in 'main', 'master' </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> $_.BranchName </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.BranchName -in 'main', 'master' </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>@(&amp; ${ugit_Format-RichText} -ForegroundColor 'Warning' ) -join ''</ScriptBlock>
              </ExpressionBinding>
              <NewLine />
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.Status -notlike 'Nothing*' </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> $_.Status + [Environment]::NewLine </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.Staged </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> 
        "Changes Staged For Commit:
  (use git commit -m to commit)" + [Environment]::NewLine
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.Staged </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        (@(foreach ($line in $($_.Staged | Select-Object ChangeType, Path | Out-String -Width ($host.UI.RawUI.BufferSize.Width - 8)) -split '(?&gt;\r\n|\n)') {
            (" " * 4) + $line
        }) -join [Environment]::NewLine) + [Environment]::NewLine
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.Unstaged </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> 
        "Changes Not Staged For Commit:
  (use git add &lt;file&gt; to add, git restore &lt;file&gt; to discard changes)" + [Environment]::NewLine
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.Unstaged</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        (@(foreach ($line in $($_.Unstaged | Select-Object ChangeType, Path | Out-String -Width ($host.UI.RawUI.BufferSize.Width - 8)) -split '(?&gt;\r\n|\n)') {
            (" " * 4) + $line
        }) -join [Environment]::NewLine) + [Environment]::NewLine
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.Untracked </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        "Untracked Files:
  (use git add &lt;file&gt; to include in commit)" + [Environment]::NewLine
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.Untracked</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        @(foreach ($line in $($_.Untracked | Out-String -Width ($host.UI.RawUI.BufferSize.Width - 8)) -split '(?&gt;\r\n|\n)') {
            (" " * 4) + $line
        }) -join [Environment]::NewLine
    </ScriptBlock>
              </ExpressionBinding>
              <Text>Nothing to commit, working tree clean</Text>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>git.submodule.status</Name>
      <ViewSelectedBy>
        <TypeName>git.submodule.status</TypeName>
      </ViewSelectedBy>
      <TableControl>
        <TableHeaders>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <TableColumnItems>
              <TableColumnItem>
                <PropertyName>Submodule</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>Reference</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>CommitHash</PropertyName>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
    <View>
      <Name>ugit.Conventional.Commit</Name>
      <ViewSelectedBy>
        <TypeName>ugit.Conventional.Commit</TypeName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>
    @(
        if ($_.README) {
            Show-Markdown -InputObject $_.README
        }

        Show-Markdown -InputObject "### Conventinal Commit Types"
        Show-Markdown -InputObject (
            '* ' + $($_.Type -join ([Environment]::NewLine + '* '))
        )
    ) -join [Environment]::NewLine
</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>ugit.extension</Name>
      <ViewSelectedBy>
        <TypeName>ugit.extension</TypeName>
      </ViewSelectedBy>
      <TableControl>
        <AutoSize />
        <TableHeaders>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <TableColumnItems>
              <TableColumnItem>
                <PropertyName>DisplayName</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>Synopsis</PropertyName>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
    <View>
      <Name>Pattern</Name>
      <ViewSelectedBy>
        <TypeName>ugit.extension</TypeName>
      </ViewSelectedBy>
      <TableControl>
        <AutoSize />
        <TableHeaders>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <TableColumnItems>
              <TableColumnItem>
                <PropertyName>DisplayName</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>Pattern</PropertyName>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
    <View>
      <Name>git.command</Name>
      <ViewSelectedBy>
        <TypeName>git.command</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>Category</PropertyName>
      </GroupBy>
      <TableControl>
        <AutoSize />
        <TableHeaders>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <TableColumnItems>
              <TableColumnItem>
                <PropertyName>Name</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>Description</PropertyName>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
  </ViewDefinitions>
</Configuration>
